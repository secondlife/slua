//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: ARES.bt
//   Authors: Harold Cindy
//   Version: 
//   Purpose: dissecting serialized Ares chunks
//  Category: 
// File Mask: *.ares
//  ID Bytes: 41 52 45 53
//   History: 
//------------------------------------------------
// This file originally based on Eris' FILEFORMAT file

LittleEndian();

typedef uchar uint8_t;
typedef double lua_Number;
typedef lua_Number Number;
typedef uint32 uint32_t;
typedef uint64 uint64_t;
typedef int16 int16_t;
typedef int32 int32_t;
// Note that in the context of Ares size_t is _always_ 64-bit!
typedef uint64 size_t;
typedef size_t ProtoPtr;

const uchar UTAG_UUID = 26;

#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TVECTOR		4
#define LUA_TSTRING		5
#define LUA_TTABLE		6
#define LUA_TFUNCTION		7
#define LUA_TUSERDATA		8
#define LUA_TTHREAD		9
#define LUA_TBUFFER		10
#define LUA_NUMTAGS		11

#define LUA_TPROTO	LUA_NUMTAGS
#define LUA_TUPVAL	(LUA_NUMTAGS+1)
#define LUA_TDEADKEY	(LUA_NUMTAGS+2)

/*
** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
*/
#define LUA_TOTALTAGS	(LUA_TUPVAL+1)

#define ERIS_PERMANENT (LUA_TOTALTAGS + 1)
#define ERIS_REFERENCE (ERIS_PERMANENT + 1)

typedef enum <uint8_t> {
    ET_NIL = LUA_TNIL,
    ET_BOOLEAN = LUA_TBOOLEAN,
    ET_LIGHTUSERDATA = LUA_TLIGHTUSERDATA,
    ET_NUMBER = LUA_TNUMBER,
    ET_VECTOR = LUA_TVECTOR,
    ET_STRING = LUA_TSTRING,
    ET_TABLE = LUA_TTABLE,
    ET_FUNCTION = LUA_TFUNCTION,
    ET_USERDATA = LUA_TUSERDATA,
    ET_THREAD = LUA_TTHREAD,
    ET_BUFFER = LUA_TBUFFER,
    ET_PROTO = LUA_TPROTO,
    ET_UPVAL = LUA_TUPVAL,
    ET_TDEADKEY = LUA_TDEADKEY,
    ET_PERMANENT = ERIS_PERMANENT,
    ET_REFERENCE = ERIS_REFERENCE,
} ErisType;

// thread status; 0 is OK
typedef enum <uint8_t>
{
    LUA_OK = 0,
    LUA_YIELD,
    LUA_ERRRUN,
    LUA_ERRSYNTAX,
    LUA_ERRMEM,
    LUA_ERRERR,
    LUA_BREAK, // yielded for a debug breakpoint
} lua_Status;

typedef enum <uint8_t> eris_CIKind {
    ERIS_CI_KIND_NONE = 0,
    ERIS_CI_KIND_LUA = 1,
    ERIS_CI_KIND_C = 2,
} eris_CIKind;

/*
** Bits in CallInfo flags
*/
#define LUA_CALLINFO_RETURN (1 << 0) // should the interpreter return after returning from this callinfo? first frame must have this set
#define LUA_CALLINFO_HANDLE (1 << 1) // should the error thrown during execution get handled by continuation from this callinfo? func must be C
#define LUA_CALLINFO_NATIVE (1 << 2) // should this function be executed using execution callback for native code

/* thread status */
#define LUA_OK		0
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRGCMM	5
#define LUA_ERRERR	6

struct Header;
struct Object;
struct String;
struct Table;
struct Closure;
struct Userdata;
struct LightUserdata;
struct Thread;
struct Buffer;
struct Proto;
struct UpVal;
struct PermKey;
struct Upvaldesc;
struct LocVar;
struct CallInfo;


// From LuauBytecode.bt
typedef enum <uint32> {
    // NOP: noop
    LOP_NOP = 0,

    // BREAK: debugger break
    LOP_BREAK,

    // LOADNIL: sets register to nil
    // A: target register
    LOP_LOADNIL,

    // LOADB: sets register to boolean and jumps to a given short offset (used to compile comparison results into a boolean)
    // A: target register
    // B: value (0/1)
    // C: jump offset
    LOP_LOADB,

    // LOADN: sets register to a number literal
    // A: target register
    // D: value (-32768..32767)
    LOP_LOADN,

    // LOADK: sets register to an entry from the constant table from the proto (number/vector/string)
    // A: target register
    // D: constant table index (0..32767)
    LOP_LOADK,

    // MOVE: move (copy) value from one register to another
    // A: target register
    // B: source register
    LOP_MOVE,

    // GETGLOBAL: load value from global table using constant string as a key
    // A: target register
    // C: predicted slot index (based on hash)
    // AUX: constant table index
    LOP_GETGLOBAL,

    // SETGLOBAL: set value in global table using constant string as a key
    // A: source register
    // C: predicted slot index (based on hash)
    // AUX: constant table index
    LOP_SETGLOBAL,

    // GETUPVAL: load upvalue from the upvalue table for the current function
    // A: target register
    // B: upvalue index
    LOP_GETUPVAL,

    // SETUPVAL: store value into the upvalue table for the current function
    // A: target register
    // B: upvalue index
    LOP_SETUPVAL,

    // CLOSEUPVALS: close (migrate to heap) all upvalues that were captured for registers >= target
    // A: target register
    LOP_CLOSEUPVALS,

    // GETIMPORT: load imported global table global from the constant table
    // A: target register
    // D: constant table index (0..32767); we assume that imports are loaded into the constant table
    // AUX: 3 10-bit indices of constant strings that, combined, constitute an import path; length of the path is set by the top 2 bits (1,2,3)
    LOP_GETIMPORT,

    // GETTABLE: load value from table into target register using key from register
    // A: target register
    // B: table register
    // C: index register
    LOP_GETTABLE,

    // SETTABLE: store source register into table using key from register
    // A: source register
    // B: table register
    // C: index register
    LOP_SETTABLE,

    // GETTABLEKS: load value from table into target register using constant string as a key
    // A: target register
    // B: table register
    // C: predicted slot index (based on hash)
    // AUX: constant table index
    LOP_GETTABLEKS,

    // SETTABLEKS: store source register into table using constant string as a key
    // A: source register
    // B: table register
    // C: predicted slot index (based on hash)
    // AUX: constant table index
    LOP_SETTABLEKS,

    // GETTABLEN: load value from table into target register using small integer index as a key
    // A: target register
    // B: table register
    // C: index-1 (index is 1..256)
    LOP_GETTABLEN,

    // SETTABLEN: store source register into table using small integer index as a key
    // A: source register
    // B: table register
    // C: index-1 (index is 1..256)
    LOP_SETTABLEN,

    // NEWCLOSURE: create closure from a child proto; followed by a CAPTURE instruction for each upvalue
    // A: target register
    // D: child proto index (0..32767)
    LOP_NEWCLOSURE,

    // NAMECALL: prepare to call specified method by name by loading function from source register using constant index into target register and copying source register into target register + 1
    // A: target register
    // B: source register
    // C: predicted slot index (based on hash)
    // AUX: constant table index
    // Note that this instruction must be followed directly by CALL; it prepares the arguments
    // This instruction is roughly equivalent to GETTABLEKS + MOVE pair, but we need a special instruction to support custom __namecall metamethod
    LOP_NAMECALL,

    // CALL: call specified function
    // A: register where the function object lives, followed by arguments; results are placed starting from the same register
    // B: argument count + 1, or 0 to preserve all arguments up to top (MULTRET)
    // C: result count + 1, or 0 to preserve all values and adjust top (MULTRET)
    LOP_CALL,

    // RETURN: returns specified values from the function
    // A: register where the returned values start
    // B: number of returned values + 1, or 0 to return all values up to top (MULTRET)
    LOP_RETURN,

    // JUMP: jumps to target offset
    // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
    LOP_JUMP,

    // JUMPBACK: jumps to target offset; this is equivalent to JUMP but is used as a safepoint to be able to interrupt while/repeat loops
    // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
    LOP_JUMPBACK,

    // JUMPIF: jumps to target offset if register is not nil/false
    // A: source register
    // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
    LOP_JUMPIF,

    // JUMPIFNOT: jumps to target offset if register is nil/false
    // A: source register
    // D: jump offset (-32768..32767; 0 means "next instruction" aka "don't jump")
    LOP_JUMPIFNOT,

    // JUMPIFEQ, JUMPIFLE, JUMPIFLT, JUMPIFNOTEQ, JUMPIFNOTLE, JUMPIFNOTLT: jumps to target offset if the comparison is true (or false, for NOT variants)
    // A: source register 1
    // D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
    // AUX: source register 2
    LOP_JUMPIFEQ,
    LOP_JUMPIFLE,
    LOP_JUMPIFLT,
    LOP_JUMPIFNOTEQ,
    LOP_JUMPIFNOTLE,
    LOP_JUMPIFNOTLT,

    // ADD, SUB, MUL, DIV, MOD, POW: compute arithmetic operation between two source registers and put the result into target register
    // A: target register
    // B: source register 1
    // C: source register 2
    LOP_ADD,
    LOP_SUB,
    LOP_MUL,
    LOP_DIV,
    LOP_MOD,
    LOP_POW,

    // ADDK, SUBK, MULK, DIVK, MODK, POWK: compute arithmetic operation between the source register and a constant and put the result into target register
    // A: target register
    // B: source register
    // C: constant table index (0..255)
    LOP_ADDK,
    LOP_SUBK,
    LOP_MULK,
    LOP_DIVK,
    LOP_MODK,
    LOP_POWK,

    // AND, OR: perform `and` or `or` operation (selecting first or second register based on whether the first one is truthy) and put the result into target register
    // A: target register
    // B: source register 1
    // C: source register 2
    LOP_AND,
    LOP_OR,

    // ANDK, ORK: perform `and` or `or` operation (selecting source register or constant based on whether the source register is truthy) and put the result into target register
    // A: target register
    // B: source register
    // C: constant table index (0..255)
    LOP_ANDK,
    LOP_ORK,

    // CONCAT: concatenate all strings between B and C (inclusive) and put the result into A
    // A: target register
    // B: source register start
    // C: source register end
    LOP_CONCAT,

    // NOT, MINUS, LENGTH: compute unary operation for source register and put the result into target register
    // A: target register
    // B: source register
    LOP_NOT,
    LOP_MINUS,
    LOP_LENGTH,

    // NEWTABLE: create table in target register
    // A: target register
    // B: table size, stored as 0 for v=0 and ceil(log2(v))+1 for v!=0
    // AUX: array size
    LOP_NEWTABLE,

    // DUPTABLE: duplicate table using the constant table template to target register
    // A: target register
    // D: constant table index (0..32767)
    LOP_DUPTABLE,

    // SETLIST: set a list of values to table in target register
    // A: target register
    // B: source register start
    // C: value count + 1, or 0 to use all values up to top (MULTRET)
    // AUX: table index to start from
    LOP_SETLIST,

    // FORNPREP: prepare a numeric for loop, jump over the loop if first iteration doesn't need to run
    // A: target register; numeric for loops assume a register layout [limit, step, index, variable]
    // D: jump offset (-32768..32767)
    // limit/step are immutable, index isn't visible to user code since it's copied into variable
    LOP_FORNPREP,

    // FORNLOOP: adjust loop variables for one iteration, jump back to the loop header if loop needs to continue
    // A: target register; see FORNPREP for register layout
    // D: jump offset (-32768..32767)
    LOP_FORNLOOP,

    // FORGLOOP: adjust loop variables for one iteration of a generic for loop, jump back to the loop header if loop needs to continue
    // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
    // D: jump offset (-32768..32767)
    // AUX: variable count (1..255) in the low 8 bits, high bit indicates whether to use ipairs-style traversal in the fast path
    // loop variables are adjusted by calling generator(state, index) and expecting it to return a tuple that's copied to the user variables
    // the first variable is then copied into index; generator/state are immutable, index isn't visible to user code
    LOP_FORGLOOP,

    // FORGPREP_INEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_inext, and jump to FORGLOOP
    // A: target register (see FORGLOOP for register layout)
    LOP_FORGPREP_INEXT,

    // removed in v3
    LOP_DEP_FORGLOOP_INEXT,

    // FORGPREP_NEXT: prepare FORGLOOP with 2 output variables (no AUX encoding), assuming generator is luaB_next, and jump to FORGLOOP
    // A: target register (see FORGLOOP for register layout)
    LOP_FORGPREP_NEXT,

    // NATIVECALL: start executing new function in native code
    // this is a pseudo-instruction that is never emitted by bytecode compiler, but can be constructed at runtime to accelerate native code dispatch
    LOP_NATIVECALL,

    // GETVARARGS: copy variables into the target register from vararg storage for current function
    // A: target register
    // B: variable count + 1, or 0 to copy all variables and adjust top (MULTRET)
    LOP_GETVARARGS,

    // DUPCLOSURE: create closure from a pre-created function object (reusing it unless environments diverge)
    // A: target register
    // D: constant table index (0..32767)
    LOP_DUPCLOSURE,

    // PREPVARARGS: prepare stack for variadic functions so that GETVARARGS works correctly
    // A: number of fixed arguments
    LOP_PREPVARARGS,

    // LOADKX: sets register to an entry from the constant table from the proto (number/string)
    // A: target register
    // AUX: constant table index
    LOP_LOADKX,

    // JUMPX: jumps to the target offset; like JUMPBACK, supports interruption
    // E: jump offset (-2^23..2^23; 0 means "next instruction" aka "don't jump")
    LOP_JUMPX,

    // FASTCALL: perform a fast call of a built-in function
    // A: builtin function id (see LuauBuiltinFunction)
    // C: jump offset to get to following CALL
    // FASTCALL is followed by one of (GETIMPORT, MOVE, GETUPVAL) instructions and by CALL instruction
    // This is necessary so that if FASTCALL can't perform the call inline, it can continue normal execution
    // If FASTCALL *can* perform the call, it jumps over the instructions *and* over the next CALL
    // Note that FASTCALL will read the actual call arguments, such as argument/result registers and counts, from the CALL instruction
    LOP_FASTCALL,

    // COVERAGE: update coverage information stored in the instruction
    // E: hit count for the instruction (0..2^23-1)
    // The hit count is incremented by VM every time the instruction is executed, and saturates at 2^23-1
    LOP_COVERAGE,

    // CAPTURE: capture a local or an upvalue as an upvalue into a newly created closure; only valid after NEWCLOSURE
    // A: capture type, see LuauCaptureType
    // B: source register (for VAL/REF) or upvalue index (for UPVAL/UPREF)
    LOP_CAPTURE,

    // removed in v3
    // LOP_DEP_JUMPIFEQK,
    // LOP_DEP_JUMPIFNOTEQK,

    // SUBRK, DIVRK: compute arithmetic operation between the constant and a source register and put the result into target register
    // A: target register
    // B: source register
    // C: constant table index (0..255); must refer to a number
    LOP_SUBRK,
    LOP_DIVRK,

    // FASTCALL1: perform a fast call of a built-in function using 1 register argument
    // A: builtin function id (see LuauBuiltinFunction)
    // B: source argument register
    // C: jump offset to get to following CALL
    LOP_FASTCALL1,

    // FASTCALL2: perform a fast call of a built-in function using 2 register arguments
    // A: builtin function id (see LuauBuiltinFunction)
    // B: source argument register
    // C: jump offset to get to following CALL
    // AUX: source register 2 in least-significant byte
    LOP_FASTCALL2,

    // FASTCALL2K: perform a fast call of a built-in function using 1 register argument and 1 constant argument
    // A: builtin function id (see LuauBuiltinFunction)
    // B: source argument register
    // C: jump offset to get to following CALL
    // AUX: constant index
    LOP_FASTCALL2K,

    // FORGPREP: prepare loop variables for a generic for loop, jump to the loop backedge unconditionally
    // A: target register; generic for loops assume a register layout [generator, state, index, variables...]
    // D: jump offset (-32768..32767)
    LOP_FORGPREP,

    // JUMPXEQKNIL, JUMPXEQKB: jumps to target offset if the comparison with constant is true (or false, see AUX)
    // A: source register 1
    // D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
    // AUX: constant value (for boolean) in low bit, NOT flag (that flips comparison result) in high bit
    LOP_JUMPXEQKNIL,
    LOP_JUMPXEQKB,

    // JUMPXEQKN, JUMPXEQKS: jumps to target offset if the comparison with constant is true (or false, see AUX)
    // A: source register 1
    // D: jump offset (-32768..32767; 1 means "next instruction" aka "don't jump")
    // AUX: constant table index in low 24 bits, NOT flag (that flips comparison result) in high bit
    LOP_JUMPXEQKN,
    LOP_JUMPXEQKS,

    // IDIV: compute floor division between two source registers and put the result into target register
    // A: target register
    // B: source register 1
    // C: source register 2
    LOP_IDIV,

    // IDIVK compute floor division between the source register and a constant and put the result into target register
    // A: target register
    // B: source register
    // C: constant table index (0..255)
    LOP_IDIVK,

    LOP__COUNT,

    LOP__LSL_START = 200,
    LOP_LSL_DOUBLE2FLOAT,
    LOP__LSL_END
} LuauOpCode;

string ReadInstruction(uint32 o) {
    local uint32 shifted_o = (o & 255);
    if (shifted_o >= LOP__COUNT)
        return Str("%u", o);
    local LuauOpCode en_o = shifted_o;
    return EnumToString(en_o);
}

typedef uint32 Instruction <read=ReadInstruction>;

// used to track logical reference numbers for parsed objects
local uint64 refNum = 0;
// tracks where we saw each reference
local uint64 refPositions[0xFFFF] = {0};

typedef struct {
    char sig[4] <bgcolor=0x33aaff>;   /* Header signature for rudimentary validation */
    Assert(sig == "ARES");
    uint8_t sizeof_number;  /* sizeof(lua_Number) to check type compatibility */
    lua_Number test;    /* -1.234567890 to check representation compatibility */
    uint8_t sizeof_int; /* sizeof(int) in persisted data */
    uint8_t sizeof_size_t;  /* sizeof(size_t) in persisted data */
    uint8_t vector_components; /* how many components are stored in vectors */
    /* Note that the last two fields determine the size of the int and size_t
     * fields in the following definitions. We write each value in the native
     * "size" and check for truncation when reading, if necessary. */
} Header <bgcolor=cLtRed>;

string ReadObject(Object &o) {
    // ref should be non-zero if present
    if (o.ourRef) {
        // ET_REFERENCE refNums are references _to_ something
        if (o.type == ET_REFERENCE) {
            return Str("%s -> #%d @%d", EnumToString(o.type), o.ourRef, refPositions[o.ourRef]);
        }
        return Str("%s #%d", EnumToString(o.type), o.ourRef);
    }
    return EnumToString(o.type);
}

typedef struct {
    // What the logical reference number of this object will be, note that this is
    // implicit and based on parse order of `Object`s!
    local int ourRef = 0;
    ErisType type <bgcolor=cLtBlue>;
    switch(type) {
        // some kinds of things don't need reference to them stored, though
        // storing references would be a waste because they're so small.
        case ET_NIL:
        case ET_BOOLEAN:
        case ET_LIGHTUSERDATA:
        case ET_NUMBER:
        case ET_VECTOR:
        // storing a reference to a reference? no.
        case ET_REFERENCE:
        // permanent never writes to the ref table, what would be the point?
        case ET_PERMANENT:
            break;
        default: {
            ourRef = ++refNum;
            // track where we saw this so we can show the address of what's
            // being referenced in ET_REFERENCEs
            refPositions[refNum] = startof(this);
        }
    }

    switch(type) {
        case ET_NIL:
            break;
        case ET_BOOLEAN:
            int32_t val; break;
        case ET_LIGHTUSERDATA:
            LightUserdata val; break;
        case ET_NUMBER:
            Number val; break;
        case ET_VECTOR:
            float val[3]; break;
        case ET_STRING:
            String val; break;
        case ET_TABLE:
            Table val; break;
        case ET_FUNCTION:
            Closure val; break;
        case ET_USERDATA:
            Userdata val; break;
        case ET_THREAD:
            Thread val; break;
        case ET_BUFFER:
            Buffer val; break;
        case ET_PROTO:
            Proto val; break;
        case ET_UPVAL:
            UpVal val; break;
        case ET_PERMANENT:
            PermKey val; break;
        case ET_REFERENCE:
            /* If the object is not primitive (see list above) we remember it and
             * increment the reference counter, and point any future occurrences of
             * it to this one via a reference (see above, Reference r). */
            /* Note that the types LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER and
             * LUA_TLIGHTUSERDATA will never be "referenced", but always be written
             * directly. */
            uint32 reference <bgcolor=cLtGreen>; /* The index the object was referenced with */
            ourRef = reference;
            break;
        default:
            Assert(0);
    }
} Object<optimize=false, bgcolor=cLtPurple, read=ReadObject>;

typedef struct {
    size_t length;      /* The length of the string */
    char str[length];   /* The actual string (not always null terminated) */
} String <read=this.str>;

typedef struct {
    size_t length;      /* The length of the buffer */
    char data[length];   /* The actual buffer data */
} Buffer <read=this.data>;

struct Table {
    uint8_t read_only;
    uint8_t safe_env;
    int array_size;
    int node_size;
    local int i;
    // This serialization format preserves `nil` holes, so we can't use `nil` as a
    // terminator.
    for (i=0; i<(array_size+node_size); ++i) {
        /* key/value pairs */
        struct Pair {
            /* Both of these may legally be `nil` due to hole preservation */
            Object key;
            Object value;
        } p <read=Str("%s : %s", ReadObject(this.key), ReadObject(this.value))>;
    }

    Object metatable;   /* The metatable (nil for none, otherwise LUA_TTABLE) */
};


typedef struct {
    uint8_t utag;       /* Userdata tag */
    if (utag == UTAG_UUID)
    {
        Object data;
    }
    else
    {
        size_t length;      /* Size of the data */
        uchar data[length]; /* The actual data */
    }
    Object metatable;   /* The metatable (nil for none, otherwise LUA_TTABLE) */
} Userdata<optimize=false>;

typedef struct {
    uint8_t lutag;       /* Userdata tag */
    size_t ptr;
} LightUserdata <read=Str("%c : %Lu", this.lutag, this.ptr)>;

struct Closure {
    uint8_t isCClosure; /* 1 if the closure is a C closure; 0 otherwise */
    uint8_t nups;       /* Number of upvalues the function uses */
    if (isCClosure) {
        struct CClosure {
            Object f;           /* The actual C function. Must be available via the
                                 * permanents table on persist and unpersist. */
            Object upvals[parentof(this).nups]; /* All upvalues */
            /* Note that here the upvalues are the actual objects, i.e. these are not
             * of type LUA_TUPVAL, since C closures' upalues are always closed. */
        } ccl;
    } else {
        struct LClosure {
            Object env;
            Object proto;       /* The proto this function uses */
            uint8_t proto_native;
            Object upvals[parentof(this).nups]; /* All upvalues */
        } lcl;
    }
};

struct UpVal {
    Object obj;         /* The object this upval refers to; we proxy it with
                         * the LUA_TUPVAL type to keep shared upvalues intact */
};

struct Proto {

    Object source;      /* Textual source for the function, string or nil */

    int bytecode_id;

    uint8_t maxstacksize;   /* Size of stack reserved for the function */
    uint8_t numparams;  /* Number of parameters taken */
    uint8_t nups;       /* Number of upvalues */
    uint8_t is_vararg;  /* 1 if function accepts varargs, 0 otherwise */

    int sizecode;       /* Number of instructions in code */
    Instruction code[sizecode]; /* The proto's code */

    int sizek;          /* Number of constants referenced */
    Object k[sizek];    /* Constants referenced */

    int sizep;          /* Number of inner Protos referenced */
    Object p[sizep];    /* Inner Protos referenced */

    int linedefined;    /* Start of line range */
    Object debugname;   /* Name of the function for debugging, string or nil */

    // Neither of these are supported yet.
    uint8_t have_lineinfo;
    if (have_lineinfo) {
        Assert(0);
        int sizelineinfo;   /* Number of opcode-line mappings */
        int lineinfo[sizelineinfo]; /* opcode-line mappings */

    }
    uint8_t debug;      /* 1 if debug data is present; 0 otherwise */
    if (debug) {
        Assert(0);
        Object source;  /* The source code string */

        int sizelocvars;    /* Number of local variable names */
        struct LocVar {
            int startpc;        /* Point where variable is active */
            int endpc;          /* Point where variable is dead */
            Object name;        /* Name of the local variable */
        } locvars[sizelocvars];    /* Local variable names */

        Object upvalnames[sizeupvalues];    /* Upvalue names */
    }

    int sizeyieldpoints;
    int yieldpoints[sizeyieldpoints];
};

struct Thread {
    Object env;
    int stacksize;      /* The overall size of the stack filled with objects,
                         * including all stack frames. */
    size_t top;         /* top = L->top - L->stack; */
    Object stack[top];    /* All stack values, bottom up */

    lua_Status status;     /* current thread status (ok, yield) */
    size_t errfunc;     /* NOT USED current error handling function (stack index) */

    int32_t num_cis;        /* number of callinfo frames */
    /* The CallInfo stack, starting with base_ci */
    struct CallInfo {
        size_t func;        /* func = ci->func - thread->stack */
        size_t top;         /* top = ci->top - thread->stack */
        size_t base;        /* base = ci->base - thread-stack */
        int32_t nresults;   /* expected number of results from this function */
        uint8_t flags;      /* What to do after completing this call, see lstate.h */
        eris_CIKind ci_kind;/* What kind of CallInfo this is */

        if (ci_kind == ERIS_CI_KIND_LUA) {
            int yield_point;
            int savedpc; /* savedpc = ci->u.l.savedpc - ci_func(ci)->p->code */
        } else if (ci_kind == ERIS_CI_KIND_C) {
            //uint8_t status;
            //if (callstatus & (CIST_YPCALL | CIST_YIELDED)) {
            //    int32_t ctx;  /* context info. in case of yields */
            //    Object k;     /* C function, callback for resuming */
            //}
            Object function;
        } else {
            Assert(ci_kind == ERIS_CI_KIND_NONE);
        }
    } ci[num_cis] <bgcolor=cLtAqua, optimize=false>;

    if (status == LUA_YIELD) {
        // size_t extra;   /* value of thread->ci->extra, which is the original
        //                 * value of thread->ci->func */
    }

    while (TRUE) {
        struct OpenUpval {
            size_t idx;         /* stack index of the value + 1; 0 if end of list */
            if (idx)
                Object upval;       /* The upvalue */
        } openupval <optimize=false>;
        if (!openupval.idx)
            break;
    }
};

struct PermKey {
    ErisType type;   /* The actual LUA_TXXX of the original value. */
    Object key;     /* The value to use as a key when unpersisting. */
    /* Note that we store the type of the original value (replaced by the
     * permanent table value used as a key when unpersisting) to ensure the
     * value in the permanents table when unpersisting has the correct type. */
};

Header header;      /* The header used for basic validation. */
Object rootobj;     /* The root object that was persisted. */
